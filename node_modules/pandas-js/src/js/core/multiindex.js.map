{"version":3,"sources":["../../es6/core/multiindex.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA;;;;;;IASa,K,WAAA,K;AAGX,iBAAY,SAAZ,EAAgC;AAAA;;AAC9B,QAAI,MAAM,OAAN,CAAc,SAAd,CAAJ,EACE,KAAK,OAAL,GAAe,oBAAU,IAAV,CAAe,SAAf,CAAf,CADF,KAEK,IAAI,qBAAqB,oBAAU,IAAnC,EACH,KAAK,OAAL,GAAe,SAAf,CADG,KAGH,MAAM,IAAI,SAAJ,CAAc,8CAAd,CAAN;AACH;;;;;;AAMD;;;;;;wBAMI,G,EAAmB;AACrB,aAAO,KAAK,OAAL,CAAa,GAAb,CAAiB,GAAjB,CAAP;AACD;;AAED;;;;;;;;;yBAMK,G,EAAmB;AACtB,aAAO,KAAK,GAAL,CAAS,GAAT,CAAP;AACD;;;wBAtBoB;AACnB,aAAO,KAAK,OAAZ;AACD;;;KA3BH;;;;IAmDa,U,WAAA,U;;AAIX;;;;;AAKA,sBAAY,SAAZ,EAA8B;AAAA;;AAC5B,QAAI,qBAAqB,oBAAU,UAAnC,EACE,KAAK,WAAL,GAAmB,WAAW,gBAAX,CAA4B,SAA5B,CAAnB,CADF,KAEK,IAAI,qBAAqB,oBAAU,IAA/B,IAAuC,MAAM,OAAN,CAAc,SAAd,CAA3C,EACH,KAAK,WAAL,GAAmB,WAAW,eAAX,CAA2B,SAA3B,CAAnB,CADG,KAGH,MAAM,IAAI,SAAJ,CAAc,0DAAd,CAAN;AACF,SAAK,OAAL,GAAe,WAAW,gBAAX,CAA4B,SAA5B,CAAf;AACD;;AAED;;;;;;;AAKA;AACA;;;;;wBAKI,G,EAA+B;AACjC,UAAI,EAAE,OAAO,GAAP,KAAe,QAAf,IAA2B,OAAO,GAAP,KAAe,QAA5C,CAAJ,EACE,MAAM,IAAI,SAAJ,CAAc,8BAAd,CAAN;;AAEF,aAAO,KAAK,WAAL,CAAiB,GAAjB,CAAqB,GAArB,CAAP;AACD;;AAED;;;;;;;;;0BAMM,I,EAAwD;AAC5D,UAAI,EAAE,MAAM,OAAN,CAAc,IAAd,KAAuB,gBAAgB,oBAAU,IAAnD,CAAJ,EACE,MAAM,IAAI,SAAJ,CAAc,4BAAd,CAAN;;AAEF,UAAI,MAAM,KAAK,WAAf;AACA,WAAK,OAAL,CAAa,UAAC,CAAD,EAAa;AAAE,cAAM,IAAI,GAAJ,CAAQ,CAAR,CAAN;AAAmB,OAA/C;AACA,aAAO,GAAP;AACD;;;wBA9BmB;AAClB,aAAO,KAAK,OAAZ;AACD;;;oCA8BsB,S,EAAoB;AACzC,UAAI,EAAE,qBAAqB,oBAAU,IAA/B,IAAuC,MAAM,OAAN,CAAc,SAAd,CAAzC,CAAJ,EACE,MAAM,IAAI,SAAJ,CAAc,sCAAd,CAAN;;AAEF,YAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AACD;;;qCAEuB,S,EAAyB;AAC/C,UAAI,EAAE,qBAAqB,oBAAU,UAAjC,CAAJ,EACE,MAAM,IAAI,SAAJ,CAAc,qDAAd,CAAN;;AAEF,aAAO,oBAAU,UAAV,CAAqB,UAAU,QAAV,GAAqB,GAArB,CAAyB,gBAAY;AAAA;AAAA,YAAV,CAAU;AAAA,YAAP,CAAO;;AAC/D,YAAI,aAAa,KAAb,IAAsB,aAAa,UAAvC,EACE,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAP,CADF,KAEK,IAAI,MAAM,OAAN,CAAc,CAAd,KAAoB,aAAa,oBAAU,IAA/C,EACH,OAAO,CAAC,CAAD,EAAI,IAAI,KAAJ,CAAU,CAAV,CAAJ,CAAP,CADG,KAEA,IAAI,aAAa,oBAAU,UAA3B,EACH,OAAO,CAAC,CAAD,EAAI,IAAI,UAAJ,CAAe,CAAf,CAAJ,CAAP;;AAEF,cAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACD,OAT2B,CAArB,CAAP;AAUD;;;qCAEuB,U,EAAyC;AAC/D,UAAI,EAAE,sBAAsB,oBAAU,UAAlC,CAAJ,EACE,MAAM,IAAI,SAAJ,CAAc,sDAAd,CAAN;;AAEF,aAAO,oBAAU,UAAV,CAAqB,WAAW,QAAX,GAAsB,GAAtB,CAA0B,iBAAY;AAAA;AAAA,YAAV,CAAU;AAAA,YAAP,CAAO;;AAChE,YAAI,aAAa,KAAjB,EACE,OAAO,CAAC,CAAD,EAAI,EAAE,MAAN,CAAP,CADF,KAEK,IAAI,aAAa,oBAAU,UAA3B,EACH,OAAO,CAAC,CAAD,EAAI,WAAW,gBAAX,CAA4B,CAA5B,CAAJ,CAAP;;AAEF,cAAM,IAAI,SAAJ,CAAc,eAAd,CAAN;AACD,OAP2B,CAArB,CAAP;AAQD","file":"multiindex.js","sourcesContent":["/** @flow\n * Created by michael on 3/22/17.\n */\n\nimport Immutable from 'immutable';\n\n\ndeclare type T_SK = string | number;\ndeclare type T_LIST = Immutable.List;\ndeclare type T_MAP = Immutable.OrderedMap;\ndeclare type T_INDEX = Array<T_SK> | T_LIST;\n\n\nexport class Index {\n  _values: T_LIST;\n\n  constructor(indexVals: T_INDEX) {\n    if (Array.isArray(indexVals))\n      this._values = Immutable.List(indexVals);\n    else if (indexVals instanceof Immutable.List)\n      this._values = indexVals;\n    else\n      throw new TypeError('Index values must be Immutable.List or Array');\n  }\n\n  get values(): T_LIST {\n    return this._values;\n  }\n\n  /**\n   * Get the index value at the idx\n   *\n   * @param {number} idx\n   * @returns {string|number}\n   */\n  get(idx: number): T_SK {\n    return this._values.get(idx);\n  }\n\n  /**\n   * Get the index value at the idx\n   *\n   * @param {number} idx\n   * @returns {string|number}\n   */\n  iloc(idx: number): T_SK {\n    return this.get(idx);\n  }\n}\n\n\nexport class MultiIndex {\n  _multiindex: T_MAP;\n  _values: Immutable.OrderedMap;\n\n  /**\n   * A MultiIndex is an Immutable.OrderedMap of MultiIndexes nested until pointing to an Index\n   *\n   * @param {Immutable.OrderedMap} indexVals\n   */\n  constructor(indexVals: T_MAP) {\n    if (indexVals instanceof Immutable.OrderedMap)\n      this._multiindex = MultiIndex._parseOrderedMap(indexVals);\n    else if (indexVals instanceof Immutable.List || Array.isArray(indexVals))\n      this._multiindex = MultiIndex._parseArrayList(indexVals);\n    else\n      throw new TypeError('index values must be OrderedMap or Iterable of Iterables');\n    this._values = MultiIndex._parseMultiIndex(indexVals);\n  }\n\n  // ***** GETTERS ***** //\n  get values(): T_MAP {\n    return this._values;\n  }\n\n  // ***** INSTANCE METHODS ***** //\n  /**\n   * Get the Index or MultiIndex at a key\n   *\n   * @param {string|number} key\n   */\n  get(key: T_SK): Index | MultiIndex {\n    if (!(typeof key === 'string' || typeof key === 'number'))\n      throw new TypeError('key must be string or number');\n\n    return this._multiindex.get(key);\n  }\n\n  /**\n   * Get the Index or MultiIndex at the key sequence\n   *\n   * @param {Array<string|number>|Immutable.List} keys\n   * @returns {*|T_MAP}\n   */\n  getIn(keys: Array<T_SK> | Immutable.List): Index | MultiIndex {\n    if (!(Array.isArray(keys) || keys instanceof Immutable.List))\n      throw new TypeError('keys must be Array or List');\n\n    let idx = this._multiindex;\n    keys.forEach((k: T_SK) => { idx = idx.get(k); });\n    return idx;\n  }\n\n  static _parseArrayList(indexVals: T_INDEX) {\n    if (!(indexVals instanceof Immutable.List || Array.isArray(indexVals)))\n      throw new TypeError('indexVals in parser must be Iterable');\n\n    throw new Error('Not implemented');\n  }\n\n  static _parseOrderedMap(indexVals: T_MAP): T_MAP {\n    if (!(indexVals instanceof Immutable.OrderedMap))\n      throw new TypeError('indexVals in parser must be an Immutable.OrderedMap');\n\n    return Immutable.OrderedMap(indexVals.entrySeq().map(([k, v]) => {\n      if (v instanceof Index || v instanceof MultiIndex)\n        return [k, v];\n      else if (Array.isArray(v) || v instanceof Immutable.List)\n        return [k, new Index(v)];\n      else if (v instanceof Immutable.OrderedMap)\n        return [k, new MultiIndex(v)];\n\n      throw new Error('Invalid value');\n    }));\n  }\n\n  static _parseMultiIndex(multiindex: T_MAP): Immutable.OrderedMap {\n    if (!(multiindex instanceof Immutable.OrderedMap))\n      throw new TypeError('multiindex in parser must be an Immutable.OrderedMap');\n\n    return Immutable.OrderedMap(multiindex.entrySeq().map(([k, v]) => {\n      if (v instanceof Index)\n        return [k, v.values];\n      else if (v instanceof Immutable.OrderedMap)\n        return [k, MultiIndex._parseMultiIndex(v)];\n\n      throw new TypeError('invalid value');\n    }));\n  }\n}\n"]}